# SeekMailAn exercise for Seek, but also a chance to learn ASP.NET Web API, Entity Framework and AngularJS.Previously I had mainly been working with NancyFx (for APIs), NHibernate, RavenDB or Dapper (for persistence), and KnockoutJS / jQuery (for client-side JavaScript).This code was produced in a fairly rushed timescale (simply due to other work I have on at the moment), so for it to be truly "production ready" I may have taken a different approach. Certainly with more close contact with stakeholders the vague requirements would definitely have been fleshed out before diving into implementation.Also, on the one hand, the requirements mentioned (and underlined) "basic", but also specified a number of advanced features and for the code to be production ready.  I've taken the approach that this is an exercise to determine whether I can build something, rather than to produce something that can immediately be used in a production environment.## APIURI | Method | Description----|--------|------------/api/templates | GET | List available message templates/api/templates | POST | Create new template/api/templates/{id} | GET | Template details/api/templates/{id} | PUT | Update template details/api/templates/{id} | DELETE | Delete template/api/templates/{id}/send | POST | Send template to email address (in body of request)/api/subscribers | GET | List of subscribers/api/subscribers | POST | Add an email to the subscriber list/api/subscribers?emailAddress={emailAddress} | DELETE | Delete a subscriber.  Note that email addresses cannot be part of the URI, they must be encoded in the query string./api/messages | GET | Get latest page of messages sent/api/messages/2 | GET | Get second page of messages sent## Some particular issues### Coding / architecture* Domain model - anemic, most of this application is purely CRUD, with one or two services for performing operations.  This is reflected in the fact that most unit tests are against the API and not the model.* Service bus - I would most certainly use a service bus for sending emails as it's an expensive process, and also the number of subscribers is variable.  I would also publish events when emails are sent to add them to the log.* Page designs - with more time I would possibly use Bootstrap or at least work on making the pages look better.* Performance - nothing has been done to optimise database indexes, client side caching, JavaScript bundling & minification, etc.* Client-side models - these just reflect the aggregates at the moment and were put there simply to illustrate that input/output models usually are separated from aggregate implementations.* Paging - while the Message Log page has next/previous paging, it would be desirable for this to work much like a notification log, where URLs do not change. In this case, rather than a page number, I would incorporate start and end message IDs into each URL.  Also, templates and subscriber lists should also be paged.* Code structure - for a more complicated application I prefer to structure files by topic rather than type (eg. "Campaign / Subscriber" rather than "Controllers / Services").* Logging - I would ordinarily include NLog in this project and log useful debug information to a database.* Exceptions - I would normally use StackExchange.Exceptional to log exceptions.* JavaScript - There is no exception logging or unit tests for the JavaScript application.  I took the exercise as more of an "AngularJS" learning exercise than a TDD approach.  Also having some useful messages appear when JavaScript errors occur, or JavaScript is disabled, should be implemented.* Deployment - I have not included any deployment scripts.### Practical use* Another aggregate, "Campaign", should ideally be introduced.  This would copy template attributes and have additional attributes for message tracking and so on.* It would certainly be more useful for this application to show statistics around campaign success (open rates, clicks, etc).* Templates should include fields that can be replaced, like the Subscriber name, or other data.* There should definitely be a HTML editor (like CKEditor) instead of pure text boxes to enter HTML.### Requirements not implementedThere are some of the initial requirements I've missed.* Campaign management - the app simply manages templates and subscribers, and allows sending test emails.* Message tracking preferences - I have not addressed the "message tracking preference" requirement.  I'm guessing that this would be either adding tracking tags to links in the email so that we can see visits from the email via Google Analytics, or a tracking pixel image to the email HTML so that we can track how many users opened the email.* Audit trail (apart from message log) - "persisting an audit trail" could mean an audit of message sent, campaign changes, template changes, subscribes/unsubscribes.* View, browse and filter audit trail - I have a simple message log with paging.  I haven't introduced filters, and the log would certainly be more useful if you could identify which campaigns the messages were sent from.## Some upsidesPersonally it's been valuable to learn these frameworks, particularly AngularJS.Web API and Entity Framework seem fairly straightforward, as with anything though when you get to certain scale it is likely that more and more in depth knowledge is required.This certainly has happened for me with NHibernate, KnockoutJS and other frameworks.